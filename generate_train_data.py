import Board # had to change python.linting.pylintEnable to false in settings.
# weird, looks like a pyLint thing.
from Game import Game

import chess
from chess.engine import Cp, Mate, MateGiven
import chess.pgn

import pickle
import os
# recall the idea here was:
# - Start the game in an initial state
# - run through the game, and for each move get stockfish's evaluation
# - store a pair: (tensor rep of board, stockfish evaluation) for training


# Want to do this in two ways: 

# 1. By pgn of a game that was played
def generate_train_data_from_PGN(pgn, out_file_path, limit, skip = 0):
    """
    (file, str, int, int -> None

    'pgn' is a file containing a PGN
    'out_file' will be used for pickling data to the training out file. Will be appended to existing data

    Writes the training data generated by the given PGN. 
        - Each move generates a pair: (a list representing the NumpyBoard, stockfish score)
    
    The file that will be serialized will contain one object: a list of every training pair
    """
    # start by unpicking any existing data to keep elements all in the same file
    out_file = open(out_file_path, "rb")
    try:
        train_list = pickle.load(out_file)
    except EOFError as e:
        train_list = []
    # Start by creating the object that will be pickled
    game_num = 0
    # Get the game from pgn
    fail_count = 0
    positions_count = 0
    game = chess.pgn.read_game(pgn)
    while game != None and game_num < limit:
        #print(game.headers["White"])
        #print(game.headers["Black"])
        #print(game.headers["Site"])
        #print(game.headers["Date"])
        positions_count = 0
        # Generate the tensorboard and py boards
        np_board =  Board.Board()
        for move in game.mainline_moves():
            # update the np board
            Game.play_move_on_np_board(np_board, move)
            #print(move)
            #print(np_board)
            #print("boards are the same:", vanilla_board == np_board.pychess_board)
            try:
                score =  engine.analyse(np_board.pychess_board, chess.engine.Limit(time=ANALYSIS_TIME))["score"]
                #vanilla_score = engine.analyse(vanilla_board, chess.engine.Limit(time=ANALYSIS_TIME))["score"]
                numerical_score = get_numerical_score(score)
                positions_count += 1
                train_list.append((np_board.board, numerical_score))
            except:
                # Sometimes the engine analysis crashes, and I'm confident it's not my own code
                # because I can run through every position in Tal.pgn no worries.
                fail_count += 1
                break # skip the rest of the game
        game = chess.pgn.read_game(pgn)
        print("finished game", game_num, "; positions from game; ", positions_count, "; fails;", fail_count)
        game_num += 1
    store_training_data(train_list, out_file_path)
    print("finished writing, total positions evaluated:", len(train_list))



def store_training_data(train_list, out_file_path):
    """
    [] of (board, score) to be pickled in outfile

    Writes over the train data to avoid having multiple lists
    """
    out_file = open(out_file_path, "wb") # should be write? No?
    pickle.dump(train_list, out_file)
    out_file.close()

def load_training_data(out_file_path):
    """
    (str) -> training list of (np_board, score)
    """
    out_file = open(out_file_path, "rb")
    train_list = pickle.load(out_file)
    #train_list_2 = pickle.load(out_file)
    print("length of list loaded: ", len(train_list))
    file_stats = os.stat(out_file_path)
    print("file size in mb:", file_stats.st_size / (1024*1024))
    out_file.close()
    return train_list

def erase_train_data(out_file_path):
    """
    WARNING: erases all the data in the file in 'out_file_path'
    """
    out_file = open(out_file_path, 'w').close()
    print("ERASED TRAIN DATA IN: ", out_file_path)


def get_numerical_score(score):
    """
    (PovScore) --> +int if white leading, -int if black leading, 0 if even

    If mate() or mate_given(), return a signal to skip terminate the game
    """
    # since white is positive, will be negative if black is leading, so
    if score.is_mate():
        return None
    return float(score.white().score())



# 2. By using running move by move what stockfish would pick (no need for me to create my own tree stuff)
#    just use the one level "for move in move, take best move" code. Need to write it haha



SF_DEPTH = 10 # depth for stockfish

ANALYSIS_TIME = 0.1 # in seconds

path = "C:/Users/Ethan/Documents/GitHub/monty/lc0-v0.26.1-windows-gpu-nvidia-cuda/lc0.exe"

engine = chess.engine.SimpleEngine.popen_uci(path)
engine.options['Ponder'] = False

train_path_tal = "C:/Users/Ethan/Documents/GitHub/monty/Tal.pgn"
train_path_carlsen = "C:/Users/Ethan/Documents/GitHub/monty/Carlsen.pgn"
train_path_ivanchuk = "C:/Users/Ethan/Documents/GitHub/monty/Ivanchuk.pgn"
train_path_nakamura = "C:/Users/Ethan/Documents/GitHub/monty/Nakamura.pgn"
train_path_kasparov = "C:/Users/Ethan/Documents/GitHub/monty/Kasparov.pgn"

out_file_path ="C:/Users/Ethan/Documents/GitHub/monty/new_outfile.txt"

debug_outfile_path = "C:/Users/Ethan/Documents/GitHub/monty/debug_outfile.txt"


if __name__ == "__main__":
    tal_file = open(train_path_tal)
    carlsen_file = open(train_path_carlsen)
    ivanchuk_file = open(train_path_ivanchuk)
    nakamura_file = open(train_path_nakamura)
    kasparov_file = open(train_path_kasparov)
    arb_lim = 10000
    # COMMENT INDICATES TRAINING COMPLETED
    #erase_train_data(out_file_path)
    #generate_train_data_from_PGN(tal_file, out_file_path, limit= arb_lim)
    #generate_train_data_from_PGN(carlsen_file, out_file_path, limit= arb_lim)
    #generate_train_data_from_PGN(ivanchuk_file, out_file_path, limit= arb_lim)
    generate_train_data_from_PGN(nakamura_file, out_file_path, limit=arb_lim)
    generate_train_data_from_PGN(kasparov_file, out_file_path, limit=arb_lim)
    print("generated")
